\documentclass[12pt,a4paper]{report}

\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{booktabs}

% The pipe character gets overriden in the code style definition, specify the table header beforehand.
\newcommand{\timetablelayout}{r|llllll}

\input{../include/language.tex}
\input{../include/styles.tex}


\begin{document}

\chapter{Вступ. Аналіз складності алгоритмів.}

% Insert table of contents.
\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup



\section{Що таке алгоритм?}
\emph{Алгоритм} --- це покроковий набір інструкцій для вирішення конкретної задачі за скінченний час та з використанням скінченного простору (пам’яті).

\vspace{0.5em}
Існує кілька способів вираження алгоритму:
\begin{itemize}
    \item Словесно --- наприклад, реченнями української чи англійської мови.
    \item Графічно --- наприклад, блок-схемою чи іншими формалізованими діаграмами.
    \item Мовою програмування.
\end{itemize}


\begin{minipage}{\linewidth}
\subsection*{Опис задачі}
Навіть найменші деталі можуть вплинути на вибір алгоритму для вирішення задачі.
Тому при її описі варто вказувати:
\begin{enumerate}
    \item Формат вхідних даних.

        {\itshape Рядок з \(N\)\ чисел, числа розділяються одним пробілом, кодування UTF-8. }

    \item Тип та діапазон значень вхідних даних.

        {\itshape Чисел може бути від 1 до 100. Всі числа --- натуральні, не більші за 50 000.}

    \item Що потрібно обчислити.

        {\itshape Знайти мінімальний елемент \(N_{min}\) з-поміж заданих \(N\) чисел.}

    \item Формат вихідних даних.

        {\itshape Одне натуральне число --- \(N_{min}\).}

\end{enumerate}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection*{Аналіз алгоритмів}
Три запитання, які дозволяють проаналізувати алгоритм:
\begin{enumerate}
    \item Чи алгоритм правильний?
    \item Наскільки алгоритм хороший?
    \item Чи можна вирішити задачу краще?
\end{enumerate}
\end{minipage}


\section{Запитання №1 --- ``Чи алгоритм правильний?''}
Незважаючи на швидкість, алгоритм перш за все повинен давати коректний результат.
Для доведення чи спростування правильності алгоритму можна використовувати такі підходи:
\begin{enumerate}
    \item Математичне доведення. Найпоширеніші методи:
        \begin{itemize}
            \item Пряме доведення.
            \item Метод індукції.
            \item Доведення від супротивного.
            \item Імовірнісне доведення.
        \end{itemize}
    \item Перебір всіх можливих варіантів вхідних даних.
    \item Знаходження контрприкладу, на якому алгоритм поверне невірний результат.
\end{enumerate}



\section{Запитання №2 --- ``Наскільки алгоритм хороший?''}
На практиці нас найбільше цікавлять два фактори:
\begin{enumerate}
    \item Час роботи алгоритму.
    \item Обсяг пам’яті, потрібної для його роботи.
\end{enumerate}

Припустимо, ми запустили алгоритм багато разів на різних вхідних даних розміром \(n\) та поміряли найкращий, найгірший та середній час виконання --- \(T(n)\).

\begin{tikzpicture}
    \begin{axis}[
        domain={2:15},
        samples={14},
        xtick={2,4,...,15},
        xlabel={\(n\) --- розмір вхідних даних},
        ylabel={\(T(n)\) --- час виконання алгоритму},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ] 
    \addplot[color=red,mark=*]  {1.5*x^2 - x + 25};
    \addplot[color=blue,mark=*] {0.7*x^2 - 0.4*x + 15};
    \addplot[color=teal,mark=*] {0.5*x^2 - 2*x + 10};
    \legend{Найгірший випадок, Середній випадок, Найкращий випадок}
    \end{axis}
\end{tikzpicture}

Наше завдання:

{\itshape Передбачити, наскільки ефективно алгоритм працюватиме на більших об’ємах вхідних даних.}

Щоб спрогнозувати, як буде зростати \(T(n)\) при зростанні \(n\), нам потрібно встановити, як саме залежить найгірший час виконання алгоритму від розміру вхідних даних.
Іншими словами, потрібно підібрати функцію, яка максимально точно описуватиме залежність \(T(n)\) від \(n\). Наприклад:
\[T(n) = 1.5n^2 - 2n + 25\]

Проте маємо проблему. Точний час --- а отже, і коефіцієнти функції --- залежить від деталей реалізації алгоритму:
\begin{itemize}
    \item від мови програмування та її компілятора/інтерпретатора.
    \item від апаратного забезпечення, на якому виконуватиметься програма.
    \item від операційної системи та поведінки інших програм, які виконуються одночасно з нашою.
\end{itemize}

Хотілося б вміти передбачити поведінку алгоритму, не реалізовуючи його. На щастя, існує інструмент, який здатен дати відповідь на це питання. Це --- \emph{асимптотичний аналіз}.

\subsection*{Асимптотичний аналіз та \(O\)-нотація}

Вважається, що функція \(f(x)\) \emph{домінує} над функцією \(g(x)\), якщо \(f(x) \geq g(x)\) на всій області визначення:

\begin{tikzpicture}
    \begin{axis}[
        domain={2:15},
        samples={14},
        xtick={2,4,...,15},
        xlabel={\(x\)},
        ylabel={\(f(x), g(x)\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,thick]  {1.5*x^2 + 3*x + 10};
    \addplot[color=teal,thick] {0.5*x^2 + 3*x + 10};
    \legend{\(f(x)\), \(g(x)\)}
    \end{axis}
\end{tikzpicture}

У випадку нижче домінування немає:

\begin{tikzpicture}
    \begin{axis}[
        domain={2:12},
        samples={20},
        xtick={2,4,...,15},
        xlabel={\(x\)},
        ylabel={\(f(x), g(x)\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,thick]  {sin(deg(x)) - 2*tan(deg(x)) + 5};
    \addplot[color=teal,thick] {1};
    \node at (axis cs:7,55) [anchor=south east] {\(x_0 = 7\)};
    \legend{\(f(x)\), \(g(x)\)}
    \end{axis}
\end{tikzpicture}

Функція \(g(x)\) називається ``\(O\)-великим'' від функції \(f(x)\), якщо ми можемо підібрати такий \emph{константний} множник \(c\) і таку початкову точку \(x_0\), при яких \(c \cdot f(x) \geq g(x)\) для всіх \(x > x_0\).

\begin{tikzpicture}
    \begin{axis}[
        domain={1:10},
        samples={30},
        xtick={2,4,...,15},
        mark repeat={2},
        xlabel={\(x\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,dashed,thick]      {x^2};
    \addplot[color=teal,thick]            {3*x^2 + 2*x + 20};
    \addplot[color=red,thick]             {5*x^2};
    \draw[dashed,black,thick] (axis cs: 3.71,1000)--(axis cs: 3.71,-1000);
    \node at (axis cs:3.71,120) [anchor=south east] {\(c = 5\)};
    \node at (axis cs:3.71,60) [anchor=south east] {\(x_0 \approx 3.71\)};
    \legend{
        \(f(x) = x^2\),
        \(g(x) = 3x^2 + 2x + 20\),
        \(c \cdot f(x) = 5x^2\)
    }
    \end{axis}
\end{tikzpicture}

Таким чином, у випадку вище \(3x^2 + 2x + 20\) є ``\(O\)-великим'' від \(x^2\).
Або ж, у математичній нотації:
\[3x^2 + 2x + 20 \in O(x^2)\]

В практичному сенсі \(O\)-нотація означає, що \(3x^2 + 2x + 20\) росте \emph{повільніше або приблизно так само}, як і \(x^2\).
Так, незважаючи на коефіцієнт \(3\), навіть при дуже великих \(x\) функції \(3x^2 + 2x + 20\) та \(x^2\) відрізнятимуться не сильно --- максимум в \(const\) кількість разів. Цього не можна сказати, наприклад, про пару функцій \(x^3\) та \(x^2\).

Тому, можна виділити кілька цікавих особливостей \(O\)-нотації:
\begin{itemize}
    \item Коефіцієнти-константи не відіграють ролі, і їх можна опустити.
        \[100x^2 \in O(x^2)\]
        \[0.04x^2 \in O(x^2)\]
    \item В многочленах роль відіграє тільки найвищий степінь, інші можна опустити.
        \[5x^2 + 3x - 103 \in O(x^2)\]
        \[2x^4 - 13x^3 + 6x^2 - 100x + 2150 \in O(x^4)\]
    \item \(O\)-нотація не означає ``тісне прилягання'' однієї функції до іншої, а лише те, що функція в лівій частині росте не швидше, ніж функція у правій. Наступні твердження також справедливі:
        \[5x^2 + 3x - 103 \in O(x^2)\]
        \[5x^2 + 3x - 103 \in O(x^3)\]
        \[5x^2 + 3x - 103 \in O(x^4)\]
        \[5x^2 + 3x - 103 \in O(2^x)\]
        \[5x^2 + 3x - 103 \in O(n!)\]

\end{itemize}


\subsection*{Застосування \(O\)-нотації до алгоритмів}

Дуже складно виміряти точну кількість машинних операцій, яку виконує алгоритм, не реалізувавши його.
Проте, оскільки для \(O\)-нотації не потрібні константи і члени нижчих порядків, ми можемо просто оцінити, чи алгоритм виконує по відношенню до \(n\) лінійну, квадратичну, кубічну, експоненціальну чи іншу кількість операцій.

І саме цього нам і достатньо для аналізу його ефективності!
Визначивши \(O\)-нотацію для часу роботи \(T(n)\), ми, по суті, прогнозуємо, як алгоритм поводиться на великих розмірах вхідних даних.
Наприклад, якщо алгоритм виконує \(O(n^2)\) операцій, значить \emph{час його роботи буде зростати не швидше, ніж квадратично, і це зазвичай не залежить від того, якою мовою ми його реалізуємо}.


\subsection*{Варіанти асимптотичних оцінок}

\(O\)-нотація дає можливість вказати верхню межу темпу зростання функції.
Хоч вона є найбільш часто вживаною характеристикою при аналізі алгоритмів, існує ще кілька нотацій, вартих уваги:

\begin{itemize}
    \item \(\Omega(f(x))\) (читається {\itshape ``омега велике''}) --- нижня асимптотична оцінка.
    \item \(\Theta(f(x))\) (читається {\itshape ``тета велике''}) --- одночасно верхня та нижня асимптотична оцінка (функція обмежується знизу функцією \(c_1 \cdot f(x)\) та зверху функцією \(c_2 \cdot f(x)\), де \(c_1, c_2\) --- множники-константи).
\end{itemize}

Також, окрім часу виконання \(T(n)\), \(O\)-,\(\Theta\)- чи \(\Omega\)-нотацію можна застосовувати для опису вимог до пам’яті \(S(n)\).

Наприклад, якщо для алгоритму вказується, що \(T(n) \in O(n^2), S(n) \in \Theta(n)\), це означає, що час роботи алгоритму в найгіршому випадку буде пропорційним до \(n^2\), а об’єм пам’яті --- в будь-якому випадку пропорційним до \(n\).



\section{Запитання №3 --- ``Чи можна вирішити задачу краще?''}

Після того, як ми довели, що алгоритм коректний та визначили асимптотичну оцінку для часу та пам’яті (наприклад, за допомогою \(O\)-нотації), можна переходити до його оптимізації.

Існує два шляхи поліпшення алгоритму:

\begin{enumerate}
    \item Покращити його реалізацію, при цьому залишивши основні кроки й асимптотичну оцінку такою ж. Зазвичай, це незначні вдосконалення, такі як використання \texttt{int32} замість \texttt{float}, інлайнінг функцій, зменшення використання віртуальних методів тощо. Зазвичай, це дозволяє прискорити алгоритм в \(const\) кількість разів.
    \item Змінити логіку роботи алгоритму так, щоб асимптотична оцінка також зменшилася.
\end{enumerate}

У другому випадку постає питання: які асимптотичні оцінки кращі, а які --- гірші? Для того, щоб порівнювати алгоритми за ефективністю, виділяють такі типові класи (в порядку зростання складності):

\begin{itemize}
    \item \emph{Константні функції} --- \(O(1)\).
    \item \emph{Логарифмічні функції} --- \(O(\log{}n)\).
    \item \emph{Лінійні функції} --- \(O(n)\).
    \item \emph{Квазілінійні функції} --- \(O(n\log{}n)\).
    \item \emph{Квадратичні функції} --- \(O(n^2)\).
    \item \emph{Кубічні функції} --- \(O(n^3)\).
    \item \emph{Експоненціальні функції} --- \(O(a^n)\), де \(a\) --- константа.
    \item \emph{Факторіальні функції} --- \(O(n!)\).
\end{itemize}

Для того, щоб побачити, наскільки суттєво відрізняються ці класи, порівняємо приблизний час виконання для різних значень \(n\):

\scalebox{0.9} {%
    \begin{tabular}{\timetablelayout}
    \toprule
    n               & \(\log{}n\)  & \(n\)       & \(n \log{}n\) & \(n^2\)       & \(2^n\)     & \(n!\) \\
    \midrule
    10              & 0.003 мкс    & 0.01 мкс    & 0.033 мкс     & 0.1 мкс       & 1 мкс       & 3.63 мс \\
    20              & 0.004 мкс    & 0.02 мкс    & 0.086 мкс     & 0.4 мкс       & 1 мс        & 77.1 років \\
    30              & 0.005 мкс    & 0.03 мкс    & 0.147 мкс     & 0.9 мкс       & 1 с         & \(8.4 \cdot 10^{15}\) років \\
    40              & 0.005 мкс    & 0.04 мкс    & 0.213 мкс     & 1.6 мкс       & 18.3 хв     & \\
    50              & 0.006 мкс    & 0.05 мкс    & 0.282 мкс     & 2.5 мкс       & 13 днів     & \\
    \midrule
    100             & 0.007 мкс    & 0.1 мкс     & 0.644 мкс     & 10 мкс        & \(4 \cdot 10^{13}\) років & \\
    1 000           & 0.01  мкс    & 1.00 мкс    & 9.966 мкс     & 1 мс          &             & \\
    10 000          & 0.013 мкс    & 10 мкс      & 130 мкс       & 100 мс        &             & \\
    100 000         & 0.017 мкс    & 0.10 мс     & 1.67 мс       & 10 с          &             & \\
    1 000 000       & 0.02  мкс    & 1 мс        & 19.93 мс      & 16.7 хв       &             & \\
    10 000 000      & 0.023 мкс    & 0.01 с      & 0.23 с        & 1.16 днів     &             & \\
    100 000 000     & 0.027 мкс    & 0.10 с      & 2.66 с        & 115.7 днів    &             & \\
    1 000 000 000   & 0.03  мкс    & 1 с         & 29.90 с       & 31.7 років    &             & \\
    \bottomrule
    \end{tabular}
}

\vspace{1em}
Типові способи зменшити складність алгоритму:
\begin{itemize}
    \item Впорядкувати дані, щоб пришвидшити пошук по них.
    \item Уникнути багаторазового розв’язування однієї й тієї ж задачі (запам’ятати проміжні результати).
    \item Використати кращу структуру даних, яка швидше працюватиме з даним алгоритмом.
\end{itemize}



\section*{Ресурси для поглибленого вивчення}
\begin{enumerate}
    \item Steven Skiena. The Algorithm Design Manual, 2\textsuperscript{nd} edition: {\itshape Chapter 2: Analysis of Algorithms}.
    \item Cormen, Leierson, Rivest, Stein. Introduction to Algorithms, 3\textsuperscript{rd} edition: {\itshape Chapter 3: Growth of Functions}.
\end{enumerate}


\end{document}
