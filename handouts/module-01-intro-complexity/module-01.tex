\documentclass[12pt,a4paper]{report}

\input{../include/language.tex}
\input{../include/style-headings.tex}
\input{../include/style-lists.tex}
\input{../include/style-paragraphs.tex}
\input{../include/debug.tex}

\usepackage{tikz}
\usepackage{pgfplots}

\begin{document}

\chapter{Вступ. Аналіз складності алгоритмів.}



\section{Що таке алгоритм?}
\emph{Алгоритм} --- це покроковий набір інструкцій для вирішення конкретної задачі за скінченний час та з використанням скінченного простору (пам’яті).

\vspace{0.5em}
Існує кілька способів вираження алгоритму:
\begin{itemize}
    \item Словесно --- наприклад, реченнями української чи англійської мови.
    \item Графічно --- наприклад, блок-схемою чи іншими формалізованими діаграмами.
    \item Мовою програмування.
\end{itemize}


\subsection*{Опис задачі}
Навіть найменші деталі можуть вплинути на вибір алгоритму для вирішення задачі.
Тому при її описі варто вказувати:
\begin{enumerate}
    \item Формат вхідних даних.

        {\itshape Рядок з \(N\)\ чисел, числа розділяються одним пробілом.}

    \item Тип та діапазон значень вхідних даних.

        {\itshape Чисел може бути від 1 до 100. Всі числа --- натуральні, не більші за 50000.}

    \item Що потрібно обчислити.

        {\itshape Знайти мінімальний елемент \(N_{min}\) з-поміж заданих \(N\) чисел.}

    \item Формат вихідних даних.

        {\itshape Одне натуральне число --- \(N_{min}\).}

\end{enumerate}


\subsection*{Аналіз алгоритмів}
Три запитання, які дозволяють проаналізувати алгоритм:
\begin{enumerate}
    \item Чи алгоритм правильний?
    \item Наскільки алгоритм хороший?
    \item Чи можна вирішити задачу краще?
\end{enumerate}



\section{Запитання №1 --- ``Чи алгоритм правильний?''}
Незважаючи на швидкість, алгоритм перш за все повинен давати коректний результат.
Для доведення чи спростування правильності алгоритму можна використовувати такі підходи:
\begin{enumerate}
    \item Математичне доведення. Найпоширеніші методи:
        \begin{itemize}
            \item Пряме доведення.
            \item Метод індукції.
            \item Доведення від супротивного.
            \item Імовірнісне доведення.
        \end{itemize}
    \item Перебір всіх можливих варіантів вхідних даних.
    \item Знаходження контрприкладу, на якому алгоритм поверне невірний результат.
\end{enumerate}



\section{Запитання №2 --- ``Наскільки алгоритм хороший?''}
На практиці нас найбільше цікавлять два фактори:
\begin{enumerate}
    \item Час роботи алгоритму.
    \item Обсяг пам’яті, потрібної для його роботи.
\end{enumerate}

Припустимо, ми запустили алгоритм багато разів на різних вхідних даних розміром \(n\) та поміряли найкращий, найгірший та середній час виконання --- \(T(n)\).

\begin{tikzpicture}
    \begin{axis}[
        domain={2:15},
        samples={14},
        xtick={2,4,...,15},
        xlabel={\(n\) --- розмір вхідних даних},
        ylabel={\(T(n)\) --- час виконання алгоритму},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ] 
    \addplot[color=red,mark=*]  {1.5*x^2 - x + 25};
    \addplot[color=blue,mark=*] {0.7*x^2 - 0.4*x + 15};
    \addplot[color=teal,mark=*] {0.5*x^2 - 2*x + 10};
    \legend{Найгірший випадок, Середній випадок, Найкращий випадок}
    \end{axis}
\end{tikzpicture}

Наше завдання:

{\itshape Передбачити, наскільки ефективно алгоритм працюватиме на більших об’ємах вхідних даних.}

Щоб спрогнозувати, як буде зростати \(T(n)\) при зростанні \(n\), нам потрібно встановити, як саме залежить найгірший час виконання алгоритму від розміру вхідних даних.
Іншими словами, потрібно підібрати функцію, яка максимально точно описуватиме залежність \(T(n)\) від \(n\). Наприклад:
\[T(n) = 1.5n^2 - 2n + 25\]

Проте маємо проблему. Точний час --- а отже, і коефіцієнти функції --- залежить від деталей реалізації алгоритму:
\begin{itemize}
    \item від мови програмування та її компілятора/інтерпретатора.
    \item від апаратного забезпечення, на якому виконуватиметься програма.
    \item від операційної системи та поведінки інших програм, які виконуються одночасно з нашою.
\end{itemize}

Хотілося б вміти передбачити поведінку алгоритму, не реалізовуючи його. На щастя, існує інструмент, який здатен дати відповідь на це питання. Це --- \emph{асимптотичний аналіз}.

\subsection*{Асимптотичний аналіз та \(O\)-нотація}

Вважається, що функція \(f(x)\) \emph{домінує} над функцією \(g(x)\), якщо \(f(x) \geq g(x)\) на всій області визначення:

\begin{tikzpicture}
    \begin{axis}[
        domain={2:15},
        samples={14},
        xtick={2,4,...,15},
        xlabel={\(x\)},
        ylabel={\(f(x), g(x)\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,thick]  {1.5*x^2 + 3*x + 10};
    \addplot[color=teal,thick] {0.5*x^2 + 3*x + 10};
    \legend{\(f(x)\), \(g(x)\)}
    \end{axis}
\end{tikzpicture}

У випадку нижче домінування немає:

\begin{tikzpicture}
    \begin{axis}[
        domain={2:12},
        samples={20},
        xtick={2,4,...,15},
        xlabel={\(x\)},
        ylabel={\(f(x), g(x)\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,thick]  {sin(deg(x)) - 2*tan(deg(x)) + 5};
    \addplot[color=teal,thick] {1};
    \node at (axis cs:7,55) [anchor=south east] {\(x_0 = 7\)};
    \legend{\(f(x)\), \(g(x)\)}
    \end{axis}
\end{tikzpicture}

Функція \(g(x)\) називається ``\(O\)-великим'' від функції \(f(x)\), якщо ми можемо підібрати такий \emph{константний} множник \(c\) і таку початкову точку \(x_0\), при яких \(c \cdot f(x) \geq g(x)\) для всіх \(x > x_0\).

\begin{tikzpicture}
    \begin{axis}[
        domain={1:10},
        samples={30},
        xtick={2,4,...,15},
        mark repeat={2},
        xlabel={\(x\)},
        legend cell align=left,
        legend style={legend pos=outer north east}
    ]
    \addplot[color=red,dashed,thick]      {x^2};
    \addplot[color=teal,thick]            {3*x^2 + 2*x + 20};
    \addplot[color=red,thick]             {5*x^2};
    \draw[dashed,black,thick] (axis cs: 3.71,1000)--(axis cs: 3.71,-1000);
    \node at (axis cs:3.71,120) [anchor=south east] {\(c = 5\)};
    \node at (axis cs:3.71,60) [anchor=south east] {\(x_0 \approx 3.71\)};
    \legend{
        \(f(x) = x^2\),
        \(g(x) = 3x^2 + 2x + 20\),
        \(c \cdot f(x) = 5x^2\)
    }
    \end{axis}
\end{tikzpicture}

Таким чином, у випадку вище \(3x^2 + 2x + 20\) є ``\(O\)-великим'' від \(x^2\).
Або ж, у математичній нотації:
\[3x^2 + 2x + 20 \in O(x^2)\]

В практичному сенсі \(O\)-нотація означає, що \(3x^2 + 2x + 20\) росте \emph{повільніше або приблизно так само}, як і \(x^2\).
Так, незважаючи на коефіцієнт \(3\), навіть при дуже великих \(x\) функції \(3x^2 + 2x + 20\) та \(x^2\) відрізнятимуться не сильно --- в \(const\) кількість разів. Цього не можна сказати, наприклад, про пару функцій \(x^3\) та \(x^2\).

Таким чином, помічаємо кілька основних особливостей \(O\)-нотації:
\begin{itemize}
    \item Коефіцієнти-константи не відіграють ролі, і їх можна опустити.
        \[100x^2 \in O(x^2)\]
        \[0.04x^2 \in O(x^2)\]
    \item В многочленах роль відіграє тільки найвищий степінь, інші можна опустити.
        \[5x^2 + 3x - 103 \in O(x^2)\]
        \[2x^4 - 13x^3 + 6x^2 - 100x + 2150 \in O(x^4)\]
    \item \(O\)-нотація не означає ``тісне прилягання'' однієї функції до іншої, а лише те, що функція в лівій частині росте не швидше, ніж функція у правій. Наступні твердження також справедливі:
        \[5x^2 + 3x - 103 \in O(x^2)\]
        \[5x^2 + 3x - 103 \in O(x^3)\]
        \[5x^2 + 3x - 103 \in O(x^4)\]
        \[5x^2 + 3x - 103 \in O(2^x)\]
        \[5x^2 + 3x - 103 \in O(n!)\]

\end{itemize}


\subsection*{Застосування \(O\)-нотації до алгоритмів}

Ми не можемо виміряти точну кількість операцій, яку виконує алгоритм, не реалізувавши його.
Проте, оскільки для \(O\)-нотації не потрібні константи і члени нижчих порядків, ми можемо просто оцінити, чи алгоритм виконує по відношенню до \(n\) лінійну, квадратичну, кубічну, експоненціальну чи іншу кількість операцій.

І саме цього нам і достатньо для аналізу його ефективності!
Визначивши \(O\)-нотацію для часу роботи \(T(n)\), ми, по суті, прогнозуємо, як алгоритм поводиться на великих розмірах вхідних даних.
Наприклад, якщо алгоритм виконує \(O(n^2)\) операцій, значить \emph{час його роботи буде зростати не швидше, ніж квадратично, незалежно від того, як ми його реалізуємо}.


\subsection*{Варіанти асимптотичних оцінок}

\(O\)-нотація дає можливість дати верхню межу темпу зростання функції.
Хоч вона є найбільш часто вживаною характеристикою при аналізі алгоритмів, існує ще кілька нотацій, вартих уваги:

\begin{itemize}
    \item \(\Omega(f(x))\) (читається {\itshape ``омега велике''}) --- нижня асимптотична оцінка.
    \item \(\Theta(f(x))\) (читається {\itshape ``тета велике''}) --- середня асимптотична оцінка (функція обмежується знизу функцією \(c_1 \cdot f(x)\) та зверху функцією \(c_2 \cdot f(x)\), де \(c_1, c_2\) --- множники-константи.
\end{itemize}

Також, окрім часу виконання \(T(n)\), \(O\)-,\(\Theta\)- чи \(\Omega\)-нотацію можна застосовувати для опису вимог до пам’яті \(S(n)\).

Наприклад, якщо для алгоритму вказується, що \(T(n) \in O(n^2), S(n) \in \Theta(n)\), це означає, що час роботи алгоритму в найгіршому випадку буде пропорційним до \(n^2\), а об’єм пам’яті --- в будь-якому випадку пропорційним до \(n\).



\section{Запитання №3 --- ``Чи можна вирішити задачу краще?''}

\end{document}
