\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{tikz}

\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{matrix}

\input{../include/language.tex}
\input{../include/styles.tex}


% TODO: Remove this after merging the modules into a single master file.
\setcounter{chapter}{4}

\tikzset{
    basic/.style = {draw, text width=30pt, circle, align=center}
}
\tikzset{
    small/.style = {draw, text width=20pt, circle, align=center}
}
\tikzset{
    blank/.style = {text width=30pt, align=center}
}
\tikzset{
    undirected/.style = {draw, thick, inner sep=5pt}
}
\tikzset{
    directed/.style = {draw, ->, thick, -{Latex[length=2.5mm]}}
}

\begin{document}

\chapter{Динамічне програмування}

% Insert table of contents.
\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup



\section{Коли вже відомі підходи не працюють}

Розглянемо нову задачу. Уявімо, що ми виграли квиток на цілий день в кінотеатр, який працює за таким розкладом:

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \draw (0, 3) rectangle (2, 6);
    \draw (1, 0) rectangle (3, 3);
    \draw (2, 3) rectangle (4, 6);
    \draw (3, 0) rectangle (5, 3);
    \draw (4, 3) rectangle (6, 6);
    \draw (5, 0) rectangle (7, 3);

    \node at (1, 5) (movie1) {Фільм A};
    \node at (2, 2) (movie2) {Фільм B};
    \node at (3, 5) (movie3) {Фільм C};
    \node at (4, 2) (movie4) {Фільм D};
    \node at (5, 5) (movie5) {Фільм E};
    \node at (6, 2) (movie6) {Фільм F};

    \begin{scope}[every node/.style={color=black!50!green, font=\large}]
        \node at (1, 4) (movie1) {1};
        \node at (2, 1) (movie2) {4};
        \node at (3, 4) (movie3) {9};
        \node at (4, 1) (movie4) {5};
        \node at (5, 4) (movie5) {1};
        \node at (6, 1) (movie6) {4};
    \end{scope}

    \path (-2, 3) edge[directed] (9, 3);
    \node at (9, 3.5) {Час};

    \end{tikzpicture}
\end{center}

Тобто, якщо ми вирішимо йти на фільм B, ми не зможемо подивитися фільми A і C. Якщо ми підемо на фільм E, ми не зможемо побачити фільми D і F.

Кожен фільм має числовий рейтинг. Рейтинг пропорційний до задоволення, яке ми отримаємо від перегляду фільму. Нам потрібно вирішити, на які фільми йти, щоб дістати максимально можливе задоволення (суму рейтингів).

Цю задачу також можна представити хронологічно у вигляді графу нижче, де \emph{вершини} мають ваги. Тепер нам потрібно знайти таку підмножину вершин, яка максимізує суму ваг, причому в цій множині не може бути жодних двох суміжних вершин.

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \begin{scope}[every node/.style=small]
        \node at (0, 0)   (movie1)  [color=black!30!red] {1};
        \node at (2, 0)   (movie2)                       {4};
        \node at (4, 0)   (movie3)  [color=black!30!red] {9};
        \node at (6, 0)   (movie4)                       {5};
        \node at (8, 0)   (movie5)                       {1};
        \node at (10, 0)  (movie6)  [color=black!30!red] {4};
    \end{scope}

    \draw (movie1)   edge[undirected]   (movie2);
    \draw (movie2)   edge[undirected]   (movie3);
    \draw (movie3)   edge[undirected]   (movie4);
    \draw (movie4)   edge[undirected]   (movie5);
    \draw (movie5)   edge[undirected]   (movie6);

    \end{tikzpicture}
\end{center}

Така задача називається Max-Weight Independent Set.

Спробуймо вирішити її способами, якими вже володіємо.

Можна застосувати \textbf{жадібний алгоритм}: якщо ми можемо йти на перший ліпший фільм, ми йдемо на нього. Тому, якщо ми прийдемо в кінотеатр із самого ранку, ми жадібно підемо на фільм A, потім на фільм C, потім на фільм E. В результаті, ми наберемо суму рейтингів 1 + 9 + 1 = 11. Навіть якщо ми повторимо цей самий алгоритм, але з кінця розкладу (4 + 5 + 4 = 13), і оберемо кращий з двох варіантів, ми наберемо суму 13. Цей результат непоганий, але не найкращий (14).

Ми також володіємо прийомом \textbf{Divide and Conquer}. Спробуємо розділити цю задачу на менші, розв’язати їх, а потім об’єднати розв’язки. Поділивши розклад на два менших --- (1, 4, 9) та (5, 1, 4), ми можемо легко визначити, на які фільми нам йти в кожній трійці (фільми [A, C] та [D, F] відповідно). Проте, об’єднавши розв’язки докупи, ми побачимо, що за умовою задачі ми не можемо піти на фільми C та D одночасно. Якщо ми спробуємо розв’язати цей конфлікт і замість фільму C піти на фільм B, ми тепер не зможемо піти на фільм A. Виглядає, що процедура об’єднання буде дуже неочевидною для цієї задачі.

Отже, з-поміж двох підходів жоден не дав вірної відповіді на задачу. Повний перебір усіх варіантів займе \(O(2 ^ N)\) часу. Все ж, чи можемо ми вирішити задачу краще?



\section{Підхід динамічного програмування}

Якщо знайомі прийоми не працюють, можна спробувати робити різні припущення щодо задачі, з надією на те, що вони приведуть нас до вірного рішення.

Уявімо, що хтось підказав нам, чи в оптимальному розв’язку задачі нам потрібно йти на \emph{останній} фільм (F), чи ні. Тоді у нас є два можливі випадки:

\begin{itemize}
    \item \emph{Не потрібно йти}. Якщо останній фільм (F) не входить в оптимальне рішення, значить кінотеатр міг би й не показувати цей фільм, і наш розв’язок від цього би не змінився. Ми б ішли на ті самі фільми незалежно від того, чи кінотеатр показує фільми A--F, чи фільми A--E. Тому розв’язок задачі для A--F дорівнюватиме розв’язку задачі для A--E.
    \item \emph{Потрібно йти}. Якщо останній фільм (F) входить в оптимальне рішення, то, за умовою задачі, фільм E точно не може в нього входити. Тому оптимальне рішення задачі для A--F дорівнюватиме оптимальному рішенню для A--D, плюс фільм F.
\end{itemize}

Звичайно ж, у реальному житті нам ніхто не дасть такої підказки. Але ми тепер можемо перевірити кращий варіант самостійно! Достатньо просто рекурсивно обчислити розв’язок для першого варіанту і для другого, і перевірити, який з них кращий.

\begin{flalign*}
    R_{A..F} & = max
    \begin{cases}
      R_{A..E} \\
      R_{A..D} + R_F
    \end{cases}
    = max
    \begin{cases}
      max
      \begin{cases}
        R_{A..D} \\
        R_{A..C} + R_E
      \end{cases}
      \\
      R_F + max
      \begin{cases}
        R_{A..C} \\
        R_{A..B} + R_D
      \end{cases}
    \end{cases}
    = & \\
    & = max
    \begin{cases}
      max
      \begin{cases}
        max
        \begin{cases}
          R_{A..C} \\
          R_{A..B} + R_D
        \end{cases}
        \\
        R_E + max
        \begin{cases}
          R_{A..B} \\
          R_{A..A} + R_C
        \end{cases}
      \end{cases}
      \\
      R_F + max
      \begin{cases}
        max
        \begin{cases}
          R_{A..B} \\
          R_{A..A} + R_C
        \end{cases}
        \\
        R_D + max
        \begin{cases}
          R_{A..A} \\
          R_{\emptyset} + R_B
        \end{cases}
      \end{cases}
    \end{cases}
    = \ldots
\end{flalign*}

Як бачимо, кількість менших задач, які нам треба обчислити, експоненціально зростає із кількістю фільмів у кінотеатрі. Тому виглядає, що ми все одно витрачаємо експоненціальний час, як і при повному переборі.

Проте поглянемо ще раз на менші задачі, які ми розв’язуємо в рекурсивних гілках. Хоч їх кількість експоненціальна, насправді ми постійно розв’язуємо лише 6 \emph{різних} задач: \(R_{\emptyset}, R_{A..A}, R_{A..B}, R_{A..C}, R_{A..D}, R_{A..E}\) (задача для 0 фільмів, для першого фільму, для перших двох фільмів, перших трьох, і т.д.). Тому ми, вперше розв’язавши якусь задачу, можемо \emph{запам’ятати її результат} і використовувати його надалі, суттєво економлячи час. Це запам’ятовування результатів функції називається \textbf{мемоізацією} (memoization).

Отже, поглянемо на нашу рекурентну формулу розв’язку:

\begin{equation*}
    R[k] = \max
    \begin{cases}
        R[k - 1] \\
        R[k - 2] + R_k
    \end{cases}
\end{equation*}

Виглядає, що розв’язок задачі для \(k\) фільмів може бути обчислений через розв’язки задачі для \(k - 1\) та \(k - 2\) фільмів. Тому ми можемо обчислити розв’язок для 0 та 1 фільмів вручну, а розв’язок для 2 фільмів (і більше) вже визначати за формулою.

Згадаймо наш граф фільмів:

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \begin{scope}[every node/.style=small]
        \node at (0, 0)   (movie1)   {1};
        \node at (2, 0)   (movie2)   {4};
        \node at (4, 0)   (movie3)   {9};
        \node at (6, 0)   (movie4)   {5};
        \node at (8, 0)   (movie5)   {1};
        \node at (10, 0)  (movie6)   {4};
    \end{scope}

    \draw (movie1)   edge[undirected]   (movie2);
    \draw (movie2)   edge[undirected]   (movie3);
    \draw (movie3)   edge[undirected]   (movie4);
    \draw (movie4)   edge[undirected]   (movie5);
    \draw (movie5)   edge[undirected]   (movie6);

    \end{tikzpicture}
\end{center}

Очевидно, що якщо ми підемо на 0 фільмів, ми заробимо суму рейтингів 0. Тому \(R[0] = 0\).

Якщо кінотеатр показує лише один фільм (A), то ми можемо піти лише на нього і заробити суму рейтингів 1. Тому \(R[1] = 1\).

Якщо кінотеатр показує перші два фільми:

\(R[2] = max(R[1], R[0] + R_2) = max(1, 0 + 4) = 4\).

Якщо кінотеатр показує перші три фільми:

\(R[3] = max(R[2], R[1] + R_3) = max(4, 1 + 9) = 10\).

Коли ми досягнемо \(R[6]\), це й буде відповіддю на наше початкове питання --- яку максимальну суму рейтингів ми можемо зібрати, якщо кінотеатр показує фільми A--F.

Таким чином, ми можемо розв’язати нашу задачу одним циклом, за час \(O(N)\):

\lstinputlisting{code/movies.py}

Ми щойно самостійно вивели ідею \textbf{динамічного програмування} (Dynamic Programming). Вона добре застосовна при таких умовах:

\begin{enumerate}
    \item Ми можемо ввести поняття більшої та меншої підзадачі.
    \item Різних підзадач є досить небагато (тоді ми можемо застосувати мемоізацію).
    \item Ми можемо встановити залежність між рішенням великої задачі та рішеннями менших.
    \item Коли ми намагаємось вирішити більшу задачу, у нас завжди є готові рішення залежних менших задач.
    \item Ми можемо самостійно дати відповідь на найменші задачі, і розбудувати з них рішення більших.
\end{enumerate}


\end{document}