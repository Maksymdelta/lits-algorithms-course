\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{tikz}

\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{matrix}

\input{../include/language.tex}
\input{../include/styles.tex}


% TODO: Remove this after merging the modules into a single master file.
\setcounter{chapter}{4}

\tikzset{
    basic/.style = {draw, text width=30pt, circle, align=center}
}
\tikzset{
    small/.style = {draw, text width=20pt, circle, align=center}
}
\tikzset{
    blank/.style = {text width=30pt, align=center}
}
\tikzset{
    undirected/.style = {draw, thick, inner sep=5pt}
}
\tikzset{
    directed/.style = {draw, ->, thick, -{Latex[length=2.5mm]}}
}

\begin{document}

\chapter{Динамічне програмування}

% Insert table of contents.
\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup



\section{Коли раніше відомі підходи не працюють}

Розглянемо нову задачу. Уявімо, що ми виграли квиток на цілий день в кінотеатр, який працює за таким розкладом:

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \draw (0, 3) rectangle (2, 6);
    \draw (1, 0) rectangle (3, 3);
    \draw (2, 3) rectangle (4, 6);
    \draw (3, 0) rectangle (5, 3);
    \draw (4, 3) rectangle (6, 6);
    \draw (5, 0) rectangle (7, 3);

    \node at (1, 5) (movie1) {Фільм A};
    \node at (2, 2) (movie2) {Фільм B};
    \node at (3, 5) (movie3) {Фільм C};
    \node at (4, 2) (movie4) {Фільм D};
    \node at (5, 5) (movie5) {Фільм E};
    \node at (6, 2) (movie6) {Фільм F};

    \begin{scope}[every node/.style={color=black!50!green, font=\large}]
        \node at (1, 4) (movie1) {1};
        \node at (2, 1) (movie2) {4};
        \node at (3, 4) (movie3) {9};
        \node at (4, 1) (movie4) {5};
        \node at (5, 4) (movie5) {1};
        \node at (6, 1) (movie6) {4};
    \end{scope}

    \path (-2, 3) edge[directed] (9, 3);
    \node at (9, 3.5) {Час};

    \end{tikzpicture}
\end{center}

Тобто, якщо ми вирішимо йти на фільм B, ми не зможемо подивитися фільми A і C. Якщо ми підемо на фільм E, ми не зможемо побачити фільми D і F.

Кожен фільм має числовий рейтинг. Рейтинг пропорційний до задоволення, яке ми отримаємо від перегляду фільму. Нам потрібно вирішити, на які фільми йти, щоб дістати максимально можливе задоволення (суму рейтингів).

Цю задачу також можна представити хронологічно у вигляді графу нижче, де \emph{вершини} мають ваги. Тепер нам потрібно знайти таку підмножину вершин, яка максимізує суму ваг, причому в цій множині не може бути жодних двох суміжних вершин.

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \begin{scope}[every node/.style=small]
        \node at (0, 0)   (movie1)  [color=black!30!red] {1};
        \node at (2, 0)   (movie2)                       {4};
        \node at (4, 0)   (movie3)  [color=black!30!red] {9};
        \node at (6, 0)   (movie4)                       {5};
        \node at (8, 0)   (movie5)                       {1};
        \node at (10, 0)  (movie6)  [color=black!30!red] {4};
    \end{scope}

    \draw (movie1)   edge[undirected]   (movie2);
    \draw (movie2)   edge[undirected]   (movie3);
    \draw (movie3)   edge[undirected]   (movie4);
    \draw (movie4)   edge[undirected]   (movie5);
    \draw (movie5)   edge[undirected]   (movie6);

    \end{tikzpicture}
\end{center}

Така задача називається Max-Weight Independent Set.

Спробуймо вирішити її способами, якими вже володіємо.

Можна застосувати \textbf{жадібний алгоритм}: якщо ми можемо йти на перший ліпший фільм, ми йдемо на нього. Тому, якщо ми прийдемо в кінотеатр із самого ранку, ми жадібно підемо на фільм A, потім на фільм C, потім на фільм E. В результаті, ми наберемо суму рейтингів 1 + 9 + 1 = 11. Навіть якщо ми повторимо цей самий алгоритм, але з кінця розкладу (4 + 5 + 4 = 13), і оберемо кращий з двох варіантів, ми наберемо суму 13. Цей результат непоганий, але не найкращий (14).

Ми також володіємо прийомом \textbf{Divide and Conquer}. Спробуємо розділити цю задачу на менші, розв’язати їх, а потім об’єднати розв’язки. Поділивши розклад на два менших --- (1, 4, 9) та (5, 1, 4), ми можемо легко визначити, на які фільми нам йти в кожній трійці (фільми [A, C] та [D, F] відповідно). Проте, об’єднавши розв’язки докупи, ми побачимо, що за умовою задачі ми не можемо піти на фільми C та D одночасно. Якщо ми спробуємо розв’язати цей конфлікт і замість фільму C піти на фільм B, ми тепер не зможемо піти на фільм A. Виглядає, що процедура об’єднання буде дуже неочевидною для цієї задачі.

Отже, з-поміж двох підходів жоден не дав вірної відповіді на задачу. Повний перебір усіх варіантів займе \(O(2 ^ N)\) часу. Все ж, чи можемо ми вирішити задачу краще?



\section{Підхід динамічного програмування}

Якщо знайомі прийоми не працюють, можна спробувати робити різні припущення щодо задачі, з надією на те, що вони приведуть нас до вірного рішення.

Уявімо, що хтось підказав нам, чи в оптимальному розв’язку задачі нам потрібно йти на \emph{останній} фільм (F), чи ні. Тоді у нас є два можливі випадки:

\begin{itemize}
    \item \emph{Не потрібно йти}. Якщо останній фільм (F) не входить в оптимальне рішення, значить кінотеатр міг би й не показувати цей фільм, і наш розв’язок від цього би не змінився. Ми б ішли на ті самі фільми незалежно від того, чи кінотеатр показує фільми A--F, чи фільми A--E. Тому розв’язок задачі для A--F дорівнюватиме розв’язку задачі для A--E.
    \item \emph{Потрібно йти}. Якщо останній фільм (F) входить в оптимальне рішення, то, за умовою задачі, фільм E точно не може в нього входити. Тому оптимальне рішення задачі для A--F дорівнюватиме оптимальному рішенню для A--D, плюс фільм F.
\end{itemize}

Звичайно ж, у реальному житті нам ніхто не дасть такої підказки. Але ми тепер можемо перевірити кращий варіант самостійно! Достатньо просто рекурсивно обчислити розв’язок для першого варіанту і для другого, і перевірити, який з них кращий.

\begin{flalign*}
    R_{A..F} & = max
    \begin{cases}
      R_{A..E} \\
      R_{A..D} + R_F
    \end{cases}
    = max
    \begin{cases}
      max
      \begin{cases}
        R_{A..D} \\
        R_{A..C} + R_E
      \end{cases}
      \\
      R_F + max
      \begin{cases}
        R_{A..C} \\
        R_{A..B} + R_D
      \end{cases}
    \end{cases}
    = & \\
    & = max
    \begin{cases}
      max
      \begin{cases}
        max
        \begin{cases}
          R_{A..C} \\
          R_{A..B} + R_D
        \end{cases}
        \\
        R_E + max
        \begin{cases}
          R_{A..B} \\
          R_{A..A} + R_C
        \end{cases}
      \end{cases}
      \\
      R_F + max
      \begin{cases}
        max
        \begin{cases}
          R_{A..B} \\
          R_{A..A} + R_C
        \end{cases}
        \\
        R_D + max
        \begin{cases}
          R_{A..A} \\
          R_{\emptyset} + R_B
        \end{cases}
      \end{cases}
    \end{cases}
    = \ldots
\end{flalign*}

Як бачимо, кількість менших задач, які нам треба обчислити, експоненціально зростає із кількістю фільмів у кінотеатрі. Тому виглядає, що ми все одно витрачаємо експоненціальний час, як і при повному переборі.

Проте поглянемо ще раз на менші задачі, які ми розв’язуємо в рекурсивних гілках. Хоч їх кількість експоненціальна, насправді ми постійно розв’язуємо лише 6 \emph{різних} задач: \(R_{\emptyset}, R_{A..A}, R_{A..B}, R_{A..C}, R_{A..D}, R_{A..E}\) (задача для 0 фільмів, для першого фільму, для перших двох фільмів, перших трьох, і т.д.). Тому ми, вперше розв’язавши якусь задачу, можемо \emph{запам’ятати її результат} і використовувати його надалі, суттєво економлячи час. Це запам’ятовування результатів функції називається \textbf{мемоізацією} (memoization).

Отже, поглянемо на нашу рекурентну формулу розв’язку:

\begin{equation*}
    R[k] = \max
    \begin{cases}
        R[k - 1] \\
        R[k - 2] + r_k
    \end{cases}
\end{equation*}

Виглядає, що розв’язок задачі для \(k\) фільмів може бути обчислений через розв’язки задачі для \(k - 1\) та \(k - 2\) фільмів. Тому ми можемо обчислити розв’язок для 0 та 1 фільмів вручну, а розв’язок для 2 фільмів (і більше) вже визначати за формулою.

Згадаймо наш граф фільмів:

\begin{center}
    \begin{tikzpicture}
    \footnotesize

    \begin{scope}[every node/.style=small]
        \node at (0, 0)   (movie1)   {1};
        \node at (2, 0)   (movie2)   {4};
        \node at (4, 0)   (movie3)   {9};
        \node at (6, 0)   (movie4)   {5};
        \node at (8, 0)   (movie5)   {1};
        \node at (10, 0)  (movie6)   {4};
    \end{scope}

    \draw (movie1)   edge[undirected]   (movie2);
    \draw (movie2)   edge[undirected]   (movie3);
    \draw (movie3)   edge[undirected]   (movie4);
    \draw (movie4)   edge[undirected]   (movie5);
    \draw (movie5)   edge[undirected]   (movie6);

    \end{tikzpicture}
\end{center}

Очевидно, що якщо ми підемо на 0 фільмів, ми заробимо суму рейтингів 0. Тому \(R[0] = 0\).

Якщо кінотеатр показує лише один фільм (A), то ми можемо піти лише на нього і заробити суму рейтингів 1. Тому \(R[1] = 1\).

Якщо кінотеатр показує перші два фільми:

\(R[2] = max(R[1], R[0] + r_2) = max(1, 0 + 4) = 4\).

Якщо кінотеатр показує перші три фільми:

\(R[3] = max(R[2], R[1] + r_3) = max(4, 1 + 9) = 10\).

Коли ми досягнемо \(R[6]\), це й буде відповіддю на наше початкове питання --- яку максимальну суму рейтингів ми можемо зібрати, якщо кінотеатр показує фільми A--F.

Таким чином, ми можемо розв’язати нашу задачу одним циклом, за час \(O(N)\):

\lstinputlisting{code/movies.py}

Якщо нам потрібно знати не лише найкращий сумарний рейтинг, а й на які конкретні фільми потрібно йти, ми можемо прослідкувати з останньої клітинки, яким шляхом ми у неї прийшли, просто перевіривши значення \(R[k - 1]\) та \(R[k - 2] + r_k\).

Щоразу, коли в формулі максимуму перемагає випадок \(R[k - 2] + r_k\), потрібно йти на \(k\)-й фільм.

\lstinputlisting{code/movies_reconstruction.py}

Ми щойно самостійно вивели ідею \textbf{динамічного програмування} (Dynamic Programming). Вона добре застосовна при таких умовах:

\begin{enumerate}
    \item Ми можемо ввести поняття більшої та меншої підзадачі.
    \item Різних підзадач є досить небагато (тоді ми можемо застосувати мемоізацію).
    \item Ми можемо встановити залежність між рішенням великої задачі та рішеннями менших.
    \item Коли ми намагаємось вирішити більшу задачу, у нас завжди є готові рішення залежних менших задач.
    \item Ми можемо самостійно дати відповідь на найменші задачі, і розбудувати з них рішення більших.
\end{enumerate}



\section{Задача про рюкзак (Knapsack Problem)}

Трохи складнішим варіантом попередньої задачі є класична задача про рюкзак (Knapsack). Її можна сформулювати так:

Ми збираємося у похід в гори і хочемо спакувати рюкзак. У нас вдома є багато предметів, кожен із яких має цінність для походу \(v_i\) і масу \(w_i\) кг. Рюкзак може вмістити максимум \(W\) кг. Які предмети нам потрібно запакувати, щоб сумарна цінність була максимально можливою, але при цьому вони вмістилися в рюкзак?

Загалом, ми маємо справу з задачею про рюкзак щоразу, коли нам треба спланувати витрати при обмеженому бюджеті так, щоб ці витрати принесли максимальну цінність.

Нехай у нас є такі предмети:

\begin{center}
    \begin{tikzpicture}
        \begin{scope}[every node/.style={blank}]
            \draw[step=1cm, gray, very thin] (0, 0) grid (4, 2);

            \matrix[matrix of nodes,
            shift={(2.0, 1.38)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {20} & {40} & {50} & {35} \\
                {5 } & {4 } & {6 } & {3 }  \\
            };

            \node at (-0.5, 1.5) {\(v_i\)};
            \node at (-0.5, 0.5) {\(w_i\)};

        \end{scope}
    \end{tikzpicture}
\end{center}

Якщо ми маємо рюкзак ємністю \(W = 11\) кг, найкращий можливий результат --- взяти предмети 2 і 3 і отримати сумарну цінність 90.

Спробуємо застосувати підхід із попередньої задачі і відповісти на питання: якщо ми знаємо, чи треба брати останній предмет в оптимальному розв’язку, що ми можемо сказати про решту предметів?

\begin{itemize}
    \item \emph{Випадок 1: не потрібно брати}. Якщо останній предмет не входить в оптимальне рішення, то розв’язок задачі для перших \(k\) предметів дорівнює розв’язку задачі для перших \(k - 1\) предметів.
    \item \emph{Випадок 2: потрібно брати}. Цей випадок складніший. Якщо ми мусимо брати \(k\)-й предмет, то решта предметів містить оптимальний розв’язок задачі для \(k - 1\) предметів та \emph{меншого рюкзака} \((W - w_k)\).
\end{itemize}

Тому ми можемо вивести таку рекурентну формулу розв’язку:

\begin{equation*}
    S(k, W) = \max
    \begin{cases}
        S(k - 1, W) \\
        S(k - 1, W - w_k) + v_k
    \end{cases}
\end{equation*}

Як бачимо, ця задача, на відміну від попередньої задачі про розклад кінотеатру, містить уже два параметри --- кількість предметів («перші \(k\)») та ємність рюкзака. Другий випадок вимагає, щоб уже була розв’язана менша задача для перших \(k - 1\) предметів та рюкзака ємністю \(W - w_k\) кг.

Тому, в цій задачі нам потрібно буде заповнювати не масив розв’язків, а матрицю \(k \times W\). Обидва випадки залежать від задачі на \(k - 1\) предметів, тому базовим випадком буде розв’язок задачі для 0 предметів з кожною можливою ємністю рюкзака.

Зрозуміло, що який би великий рюкзак у нас не був, ми отримаємо цінність 0, якщо у нас немає жодного предмета.

\begin{center}
    \begin{tikzpicture}
        \begin{scope}[every node/.style={blank}]
            \draw[step=1cm, gray, very thin] (0, 0) grid (5, 12);

            \matrix[matrix of nodes,
            shift={(2.5, 6.38)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
                {0 } & {  } & {  } & {  } & {  } \\
            };

            \matrix[matrix of nodes,
            shift={(-0.5, 6.38)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {11} \\ {10} \\ {9} \\ {8} \\ {7} \\ {6} \\ {5} \\ {4} \\ {3} \\ {2} \\ {1} \\ {0} \\
            };

            \matrix[matrix of nodes,
            shift={(2.5, 0.0)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {0} & {1} & {2} & {3} & {4} \\
            };

            \node at (5.7, -0.35) {\(k\)};
            \node at (-0.5, 12.7) {\(W\)};

        \end{scope}
    \end{tikzpicture}
\end{center}

Тепер, поступово заповнюючи цю таблицю по стовпцях за допомогою рекурентної формули, отримаємо таку таблицю:

\begin{center}
    \begin{tikzpicture}
        \begin{scope}[every node/.style={blank}]
            \draw[step=1cm, gray, very thin] (0, 0) grid (5, 12);

            \matrix[matrix of nodes,
            shift={(2.5, 6.38)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {0} & {20} & {60} & {90} & {90} & \\
                {0} & {20} & {60} & {90} & {90} & \\
                {0} & {20} & {60} & {60} & {85} & \\
                {0} & {20} & {40} & {50} & {75} & \\
                {0} & {20} & {40} & {50} & {75} & \\
                {0} & {20} & {40} & {50} & {50} & \\
                {0} & {20} & {40} & {40} & {40} & \\
                {0} & {0}  & {40} & {40} & {40} & \\
                {0} & {0}  & {0}  & {0}  & {35} & \\
                {0} & {0}  & {0}  & {0}  & {0}  & \\
                {0} & {0}  & {0}  & {0}  & {0}  & \\
                {0} & {0}  & {0}  & {0}  & {0}  & \\
            };

            \matrix[matrix of nodes,
            shift={(-0.5, 6.38)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {11} \\ {10} \\ {9} \\ {8} \\ {7} \\ {6} \\ {5} \\ {4} \\ {3} \\ {2} \\ {1} \\ {0} \\
            };

            \matrix[matrix of nodes,
            shift={(2.5, -0.1)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {0} & {1} & {2} & {3} & {4} \\
            };

            \node at (5.7, -0.35) {\(k\)};
            \node at (-0.5, 12.7) {\(W\)};

        \end{scope}
    \end{tikzpicture}
\end{center}

Як і у випадку з кінотеатром, ми тепер можемо взяти з таблиці готовий розв’язок початкової задачі. Нас цікавить сумарна цінність, коли ми маємо усі 4 предмети і рюкзак ємністю 11 кг, відповідно \(S(4, 11) = 90\), що й є найкращим варіантом.

Також, аналогічно до попередньої задачі, якщо нам потрібні конкретні предмети, а не лише значення сумарної цінності, ми можемо відслідкувати логіку роботи алгоритму ззаду наперед, стартуючи з останньої клітинки. Якщо виграє випадок №2 --- ми беремо \(k\)-й предмет в похід.

Отже, якщо ваги предметів --- цілочисельні, то ми можемо розв’язати задачу рюкзака методом динамічного програмування за час і простір \(O(N \cdot W)\).



\section{Динамічне програмування для графів}

Коли ми розглядали найкоротші шляхи у зважених графах, алгоритм Дейкстри задовільняв наші основні потреби. Проте він міг давати некоректну відповідь, коли в графі були присутні ребра від’ємної ваги. Подивимося, чи допоможе в цьому випадку динамічне програмування.

Як уже відомо, першим кроком до динамічного програмування є виділення більших та менших задач, які перетинаються, а також закономірностей між ними. У задачі про кінотеатр чи рюкзак це було легко зробити. Натомість, граф є значно більш нелінійною структурою, для якої не очевидні більші та менші задачі. Дійсно, якщо ми розглядатимемо лише перші \(k\) вершин, за аналогією до попередніх задач, ми будемо змушені вилучати з графу ще й ребра.

Спробуймо придумати «штучні» більші й менші задачі. Легко показати, що якщо у графі є \(V\) вершин, то кількість ребер в найкоротшому шляху між будь-якими двома вершинами буде не більша, ніж \(V - 1\). Тому спробуємо скористатися цим і ввести «бюджет» на кількість ребер у шляху.

Спочатку дозволимо всім найкоротшим шляхам мати максимум \(k = 0\) ребер. З таким бюджетом \(k\) ми зможемо добратися лише до стартової вершини (і пройдемо відстань 0). До всіх решта вершин відстань зі стартової вершини буде \(\infty\). Це й буде нашим базовим випадком, і він фактично повторює ініціалізацію з алгоритму Дейкстри:

\begin{center}
    \(D(v_{i}, k = 0) = \infty\)

    \(D(v_{start}, k = 0) = 0\)
\end{center}

Тепер, якщо ми збільшимо бюджет на 1 ребро, ми маємо більшу свободу вибору. У нас тепер є дві стратегії для кожної вершини \(v_i\):

\begin{enumerate}
    \item Піти шляхом, який ми знали раніше, ігноруючи збільшений бюджет.
    \item Спробувати дійти за максимум \(k - 1\) кроків до якогось із сусідів даної вершини \(v_{adj}\), і скористатися фінальним \(k\)-м кроком, щоб пройти по ребру \(v_{adj} \rightarrow v_i\).
\end{enumerate}

Так, крок за кроком, ми нарешті дозволимо всім найкоротшим шляхам мати \(k = V - 1\) ребро, і автоматично отримаємо відповідь на початкову задачу.

Отже, рекурентна формула розв’язків буде такою:

\begin{center}
    \(
        D(v_i, k) = \min
        \begin{cases}
            D(v_i, k - 1) \\
            \min\limits_{v_{adj} \rightarrow v_i} \{ D(v_{adj}, k - 1) + w(v_{adj} \rightarrow v_i) \}
        \end{cases}
    \)
\end{center}

Як і у задачі з рюкзаком, ми заповнюватимемо прямокутну таблицю \(V \times k\), і візьмемо готові відповіді з колонки \(k = V - 1\).

Цей алгоритм називається \textbf{алгоритмом Беллмана-Форда}. Він здатен працювати з від’ємними ребрами, проте граф мусить не мати циклів від’ємної ваги. Дійсно, коли граф має цикли від’ємної ваги, то найкоротші шляхи до вершин в циклі будуть мати нескінченну кількість ребер.

Існує кмітливий трюк, який допомагає алгоритму Беллмана-Форда виявляти цикли від’ємної ваги. Ми просто запускаємо його на ще одну ітерацію \(k = V\), і якщо хоч раз переміг випадок №2, ми видаємо помилку, що знайдено цикл від’ємної ваги. В інакшому випадку, алгоритм би не знайшов жодного кращого шляху, як сильно ми б не збільшували бюджет.

В коді цей алгоритм виглядатиме так:

\lstinputlisting{code/bellman_ford.py}



\section{Нечітке порівняння тексту}

При розробці алгоритмів, пов’язаних із текстом, нам може бути потрібно визначити ступінь подібності двох стрічок. Це корисно, наприклад, для задач автоматичного виправлення орфографії (spellchecking) або автодоповнення (autocomplete). Також схоже завдання може виникати в геноміці при визначенні схожості двох послідовностей в ДНК різних організмів (Needleman-Wunsch Score).

Отже, опишемо задачу більш формально. Ми маємо стрічку \(X\) довжиною \(m\) символів та стрічку \(Y\) довжиною \(n\) символів. Потрібно розташувати стрічку \(Y\) під стрічкою \(X\), доповнивши їх пробілами в довільних місцях. Якщо в отриманому розташуванні деякий символ \(y_i \neq x_i\), ми отримуємо штраф \(\delta_{mismatch}\). Якщо \(y_i\) співставлений з пробілом чи \(x_i\) співставлений з пробілом, ми отримуємо штраф \(\delta_{gap}\). Наприклад, для \(\delta_{mismatch} = 3, \delta_{gap} = 1\):

\begin{lstlisting}
    X = ACTTGA
    Y = CATG

    X alignment:    ACTTGGA           ACTTGGA            .ACTTGA
    Y alignment:    CATG...           .CATG..            CA.T.G.
    Penalty:        3303111  -> 12    1030011  -> 7      1010101  -> 4
\end{lstlisting}

Нам потрібно знайти таке розташування стрічок, яке б давало мінімальний можливий сумарний штраф (в даному випадку 4).

Уявімо крайню праву позицію в оптимальному розташуванні стрічок. В нашій задачі ми матимемо три можливі випадки:

\begin{enumerate}
    \item Останній символ \(x_m\) стрічки \(X\) розташований над останнім символом \(y_n\) стрічки \(Y\). В такому випадку штраф, який ми отримаємо, буде \(\delta_{mismatch}\), якщо \(x_m \neq y_n\), інакше \(\delta = 0\).
    \item Останній символ \(x_m\) стрічки \(X\) розташований над пробілом. Штраф --- \(\delta_{gap}\).
    \item Останній символ \(y_n\) стрічки \(Y\) розташований під пробілом. Штраф --- \(\delta_{gap}\).
\end{enumerate}

Зауважимо, що четвертого варіанту --- пробіл розташований над пробілом --- бути не може, оскільки ми можемо відкинути ці пробіли і зекономити \(\delta_{gap}\) штрафу.

Тепер, якщо ми знаємо оптимальне розташування символів в останній позиції, то частини стрічок \(X, Y\), які залишилися, будуть меншими підзадачами:

\begin{center}
    \( \Delta(i, j) = \max
        \begin{cases}
            \Delta(i - 1, j - 1) + \delta_{mismatch} \{x_i \neq y_j \} \\
            \Delta(i - 1, j) + \delta_{gap} \\
            \Delta(i, j - 1) + \delta_{gap} \\
        \end{cases}
    \)
\end{center}

В формулі вище \(i, j\) --- це скільки перших символів ми беремо зі стрічок \(X\) та \(Y\) відповідно.

Залишилося тільки заповнити базовий випадок:

\begin{center}
    \(\Delta(i, 0), \Delta(0, j)\) для \(i \in [0..m], j \in [0..n]\)
\end{center}

По суті, \(\Delta(3, 0)\) означає, що ми використали 3 символи з першої стрічки, а з другої --- жодного. Це означає, що ми доповнили другу стрічку 3-ма пробілами зліва. Тому \(\Delta(i, 0) = i \cdot \delta_{gap}, \Delta(0, j) = j \cdot \delta_{gap}\).
 
Таблиця розв’язків для нашого прикладу (|X = ACTTGA, Y = CATG|) буде такою:

\begin{center}
    \begin{tikzpicture}
        \begin{scope}[every node/.style={blank}]
            \draw[step=1cm, gray, very thin] (0, 0) grid (5, 7);

            \matrix[matrix of nodes,
            shift={(2.5, 3.88)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {6} & {5} & {4} & {5} & {4} & \\
                {5} & {4} & {5} & {4} & {3} & \\
                {4} & {3} & {4} & {3} & {4} & \\
                {3} & {2} & {3} & {2} & {3} & \\
                {2} & {1} & {2} & {3} & {4} & \\
                {1} & {2} & {1} & {2} & {3} & \\
                {0} & {1} & {2} & {3} & {4} & \\
            };

            \matrix[matrix of nodes,
            shift={(-1.05, 3.88)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {|A|} & {6} \\
                {|G|} & {5} \\
                {|T|} & {4} \\
                {|T|} & {3} \\
                {|C|} & {2} \\
                {|A|} & {1} \\
                {| |} & {0} \\
            };

            \matrix[matrix of nodes,
            shift={(2.5, -0.62)},
            inner sep=0pt,
            anchor=center,
            nodes={inner sep=0pt, text width=1cm, align=center, text height=1cm}
            ]{
                {0}   & {1}   & {2}   & {3}   & {4}   \\
                {| |} & {|C|} & {|A|} & {|T|} & {|G|} \\
            };

            \node at (-0.5, 7.7) {\(i\)};
            \node at (5.7, -0.5) {\(j\)};

        \end{scope}
    \end{tikzpicture}
\end{center}

Таким чином, ми визначимо, що, використавши всі 6 символів із першої стрічки та 4 символи з другої, ми можемо в найкращому випадку отримати штраф \(\Delta(6, 4) = 4\).
Якщо нам потрібно отримати самі розташування стрічок, а не лише штраф, ми діємо аналогічно до попередніх задач --- крокуємо від останньої клітинки в напряму початкової, перевіряючи, який випадок (1, 2 чи 3) переміг на кожному кроці.

Якщо \(\delta_{mismatch} = \delta_{gap} = 1\), то ця задача називається задачею \textbf{відстані Левенштейна} (Levenshtein Distance). Ця відстань --- мінімально необхідна кількість операцій додавання символу, вилучення символу та заміни символу, щоб зробити зі стрічки \(X\) стрічку \(Y\) чи навпаки.



\section*{Ресурси для поглибленого вивчення}
\begin{enumerate}
    \item Steven Skiena. The Algorithm Design Manual, 2\textsuperscript{nd} edition: {\itshape Chapter 8: Dynamic Programming}.
    \item Cormen, Leierson, Rivest, Stein. Introduction to Algorithms, 3\textsuperscript{rd} edition: {\itshape Chapter 15: Dynamic Programming}.
    \item Dynamic Programming Practice Problems:

          \href{https://people.cs.clemson.edu/~bcdean/dp_practice/}{https://people.cs.clemson.edu/\textasciitilde bcdean/dp\_practice/}
\end{enumerate}

\end{document}