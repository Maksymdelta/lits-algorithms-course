\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{tikz}

\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.misc}

\input{../include/language.tex}
\input{../include/styles.tex}


% TODO: Remove this after merging the modules into a single master file.
\setcounter{chapter}{2}

\tikzset{
    basic/.style  = {draw, text width=20pt, circle, align=center}
}

\begin{document}

\chapter{Пошук}

% Insert table of contents.
\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup



\section{Задача пошуку}

Пошук дозволяє нам справлятися з величезними потоками інформації у повсякденному житті, відокремлюючи тільки потрібні для нас дані. Щоразу, коли ми шукаємо інформацію в Google, отримуємо телефонний дзвінок від людини, яка є у нашому списку контактів, чи вибираємо купюри з гаманця, щоб оплатити якийсь товар готівкою, виконується задача пошуку.

За аналогією з попередніми задачами, спробуємо описати задачу пошуку більш формально.

У нас є \(N\) об’єктів, кожен з яких має певний унікальний ключовий атрибут \(key\). Ми хочемо зберегти усі ці об’єкти так, щоб кожного із них можна було потім знайти за ключем \(key\) (або виявити, що такого об’єкта не існує). Наприклад, якщо в телефонному програмному забезпеченні потрібно показати, яка людина нам телефонує, маючи номер її телефону, то в телефонній книзі об’єктами будуть люди, а ключовим атрибутом буде номер телефону.

Структура даних, яка реалізовує задачу пошуку, повинна підтримувати такі базові операції:

\begin{enumerate}
    \item |Add(key, value)| -- додати елемент |value| із ключем |key| до бази пошуку.
    \item |Get(key)| -- знайти в базі eлемент (|value|) за ключем |key|, або повідомити, що такого елемента нема.
\end{enumerate}

Деякі структури, які ми розглянемо далі, можуть підтримувати додаткові операції, наприклад:
\begin{itemize}
    \item |Remove(key)| -- вилучити елемент з бази.
    \item |Exists(key)| -- перевірити, чи елемент існує в базі.
    \item |FindAllInRange(rangeStart, rangeEnd)| -- знайти усі елементи, де ключ лежить в діапазоні від |rangeStart| до |rangeEnd|.
\end{itemize}



\section {Бінарний пошук}

Припустимо, нам потрібно зберігати базу користувачів веб-сайту, де кожен користувач має унікальний ідентифікатор -- |username|. Нехай у нас є користувачі |alice|, |bob|, |charlie|, |dave|, |eve|, |fred|, |george|, тощо.

Спробуємо реалізувати структуру даних для пошуку. Для початку, використаємо звичайний невпорядкований масив. Тоді операція |Add| буде дописувати елементи в кінець масиву, а операція |Get| -- сканувати весь масив, доки не знайде в ньому елемент з заданим ключем.

Після додавання кількох користувачів в довільному порядку наш масив може виглядати так:

\begin{center}
    \begin{tikzpicture}
        \footnotesize
        \draw[step=3cm,gray,very thin] (0,0) grid (15,1);
        \draw node at (11.5,2.0) (insert-label) {місце вставки нового елемента};

        \normalsize
        \draw node at (1.5,0.5) {dave};
        \draw node at (4.5,0.5) {alice};
        \draw node at (7.5,0.5) {fred};
        \draw node at (10.5,0.5) {bob};
        \draw node at (13.5,0.5) (insert-cell) {};

        \draw [draw,->,thick,-{Latex[length=2.5mm]}] (insert-label) -- (insert-cell);
    \end{tikzpicture}
\end{center}

Як і у випадку з Priority Queue з попереднього розділу, швидкодія такого підходу доволі очевидна: ми будемо вставляти новий елемент за \(O(1)\), проте час пошуку буде лише \(O(N)\). Якщо припустити, що ми змінюємо базу даних значно рідше, ніж шукаємо в ній елементи, такий підхід буде надто повільним.

Проте, ми вже володіємо прийомами сортування. Можливо, вигідніше буде впорядкувати дані, щоб потім пошук по них відбувався швидше?

\begin{center}
    \begin{tikzpicture}
        \footnotesize
        \draw[step=2cm,gray,very thin] (0,0) grid (16,1);
        \normalsize
        \draw node at (1,0.5) {alice};
        \draw node at (3,0.5) {bob};
        \draw node at (5,0.5) {charlie};
        \draw node at (7,0.5) {dave};
        \draw node at (9,0.5) {eve};
        \draw node at (11,0.5) {fred};
        \draw node at (13,0.5) {george};
        \draw node at (15,0.5) {henry};
    \end{tikzpicture}
\end{center}

Припустимо, ми шукаємо користувача |bob|. Тепер глянемо на довільний елемент нашого впорядкованого масиву. Нехай це буде |fred|. Оскільки |bob| < |fred|, ми можемо бути впевнені, що |bob| не може бути правіше, ніж |fred| у масиві. Тому ми можемо взагалі відкинути всю праву частину, і продовжувати пошук |bob| лише в лівій!

На цій логіці базується алгоритм \textbf{бінарного пошуку}:
\begin{enumerate}
    \item Якщо масив порожній --- шуканого елемента не існує.
    \item Інакше --- порівнюємо середній елемент з шуканим значенням.
    \item Якщо середній елемент дорівнює шуканому значенню, повертаємо цей елемент як результат пошуку.
    \item Якщо середній елемент більший за шукане значення, повторюємо кроки 1--5 для лівої половини масиву.
    \item Якщо середній елемент менший за шукане значення, повторюємо кроки 1--5 для правої половини масиву.
\end{enumerate}

Для нашого прикладу з користувачами, спробуємо знайти |charlie|:
\begin{enumerate}
    \item Середній елемент --- |dave|. |charlie| < |dave|, тому звужуємо пошук до лівої половини (|alice| -- |charlie|).
    \item Тепер середній елемент --- |bob|. |charlie| > |bob|, тому звужуємо пошук до правої половини (|charlie| -- |charlie|).
    \item Тепер середній елемент --- |charlie|. Ми знайшли шуканий елемент.
\end{enumerate}

Логіка бінарного пошуку є рекурсивною, проте в коді ми можемо замінити рекурсію на цикл:

\lstinputlisting{code/binary_search.py}

Таким чином, на кожному кроці наша область пошуку скорочується вдвічі, тому ми можемо знайти будь-який елемент за \(O(\log N)\) часу. Ми лише мусимо затратити певний час на те, щоб спочатку впорядкувати дані. Тому бінарний пошук --- це хороший алгоритм, коли нам потрібно багато разів шукати елементи у незмінному наборі даних.

Зрозуміло, що ми все ще маємо проблему із тим, що вставляти дані в посортований масив ми можемо лише за \(O(N)\). Про можливі її рішення ми поговоримо в наступних розділах.

Інколи у нас може бути потреба серед усіх рівних елементів масиву знайти найлівіший чи найправіший:

\begin{center}
    \begin{tikzpicture}
        \footnotesize
        \draw[step=1cm,gray,very thin] (0,0) grid (10,1);
        \draw node at (1.5,2.0) (leftmost-label) {найлівіший елемент 3};
        \draw node at (6.5,2.0) (rightmost-label) {найправіший елемент 3};

        \normalsize
        \draw node at (0.5,0.5) {0};
        \draw node at (1.5,0.5) {1};
        \draw node at (2.5,0.5) (leftmost-cell) {3};
        \draw node at (3.5,0.5) {3};
        \draw node at (4.5,0.5) {3};
        \draw node at (5.5,0.5) (rightmost-cell) {3};
        \draw node at (6.5,0.5) {4};
        \draw node at (7.5,0.5) {5};
        \draw node at (8.5,0.5) {6};
        \draw node at (9.5,0.5) {9};

        \draw [draw,->,thick,-{Latex[length=2.5mm]}] (leftmost-label) -- (leftmost-cell);
        \draw [draw,->,thick,-{Latex[length=2.5mm]}] (rightmost-label) -- (rightmost-cell);

    \end{tikzpicture}
\end{center}

Цю задачу все ще можна вирішити бінарним пошуком за \(O(\log N)\) --- все тільки залежить від тонких деталей, як саме ми будемо порівнювати елементи та скорочувати діапазон пошуку:

\lstinputlisting{code/binary_search_edge.py}


\end{document}