\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}

\input{../include/language.tex}
\input{../include/styles.tex}


% TODO: Remove this after merging the modules into a single master file.
\setcounter{chapter}{5}


\begin{document}

\chapter{Класи складності задач}

% Insert table of contents.
\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup



\section{Обчислювальна придатність задач}

Протягом попередніх розділів ми часто стикалися із ситуацією, коли вирішувати задачу повним перебором було надто довго --- \(O(2^n), O(n!)\) тощо. На допомогу нам завжди приходив певний алгоритм --- або жадібний, або на основі Divide and Conquer, динамічного програмування тощо, який вирішував задачу суттєво швидше. Проте, на жаль, існує багато задач, для яких людство ще не придумало ефективного алгоритму. Як дізнатися, чи наша задача взагалі вирішується швидко, чи навіть не варто сподіватися знайти швидкий розв’язок?

Пригадаймо найбільш типові складності алгоритмів із першого розділу:

\begin{itemize}
    \item \emph{Константні функції} --- \(O(1)\).
    \item \emph{Логарифмічні функції} --- \(O(\log{}n)\).
    \item \emph{Лінійні функції} --- \(O(n)\).
    \item \emph{Квазілінійні функції} --- \(O(n\log{}n)\).
    \item \emph{Квадратичні функції} --- \(O(n^2)\).
    \item \emph{Кубічні функції} --- \(O(n^3)\).
    \item \emph{Експоненціальні функції} --- \(O(a^n)\), де \(a\) --- константа.
    \item \emph{Факторіальні функції} --- \(O(n!)\).
\end{itemize}

Якщо поглянути на ширший світ алгоритмів, загалом вважається, що «швидкими» є алгоритми, які мають складність \(O(P ^ a(n))\), де \(P ^ a(n)\) --- многочлен деякого фіксованого степеня \(a\) \((a = const)\), а \(n\) --- довжина вхідних даних. Таким чином, усі складності алгоритмів з нашого списку, крім останніх двох, вважатимуться швидкими. Більше того, на основі цього правила, навіть \(O(n ^ {10}), O(n ^ {50})\) вважаються академічно «швидкими», хоч і на практиці вони будуть слабо застосовні при великих об’ємах даних.



\section{Класи P та NP. Зведення задач}

Усі задачі, які можна розв’язати за час \(O(P ^ a(n))\), формують \textbf{клас задач P} (polynomial). Більшість задач, з якими ми мали справу раніше, були саме \(P\)-задачами: сортування масивів, черга з пріоритетами, обхід графу, найкоротші шляхи на графі без циклів від’ємної ваги, топологічне сортування, відстань Левенштейна тощо.

Вагомим винятком є задача про рюкзак. Навіть якщо ваги предметів цілочисельні, вона розв’язувалася за час \(O(n \cdot W)\). Невже це не многочлен фіксованого степеня? Так, проте для належності до класу P многочлен має залежати від \emph{довжини} вхідних даних, а \(W\) --- це окремий параметр серед даних. Якщо ми збільшимо тільки параметр \(W\) у 100 разів, не змінюючи кількість предметів, час пошуку розв’язку збільшується у 100 разів. Таким чином, задача про рюкзак не належить до \(P\).

Можливо, існує алгоритм, який розв’язує задачу рюкзака за час \(O(P ^ a(n))\), проте людство його ще не винайшло. Для цього виділяється інший клас задач, який є узагальненням класу P.

Спочатку розглянемо простіший варіант задачі рюкзака. Нехай, як і в попередньому варіанті, нам задано \(n\) предметів з цінностями \(v_i\) та вагами \(w_i\), а також бюджет \(W\). Проте запитання тепер ставиться простіше: чи можна, маючи бюджет \(W\), набрати предметів на сумарну цінність щонайменше \(V\)? Така задача називається Knapsack-Desicion (а початкова задача, де нам потрібно було знайти найкращий можливий варіант --- Knapsack-Optimization).

Якщо хтось дасть нам готову відповідь на Knapsack-Desicion (наприклад, «так, можна набрати цінність \(\geq V\), для цього потрібно взяти предмети 1, 2, 6»), ми зможемо перевірити, чи ця відповідь вірна, за P-час.

Задачі, відповіді на які можуть бути перевірені за P-час, формують \textbf{клас задач NP} (nondeterministic polynomial). Важливо пам’ятати, що належність задачі до NP не означає, що P-алгоритму для неї не існує, а лише те, що такий алгоритм не винайдений.

Таким чином, задача Knapsack-Desicion входить до NP. Проте її Optimization-версія --- ні (ми не можемо за P-час перевірити, чи відповідь --- дійсно найкращий варіант).

Класи P та NP дають хороше підгрунтя для аналізу невідомих задач: вони дозволяють нам порівнювати задачі між собою за відносною складністю.

Припустимо, що нам задано зважений граф з додатніми вагами ребер, і потрібно знайти найкоротші шляхи між \emph{усіма} парами вершин. Ми знаємо, що алгоритм Дейкстри може знайти найкоротші шляхи з \emph{однієї} вершини до всіх інших. Проте якщо ми запустимо алгоритм Дейкстри з кожної вершини, ми вирішимо початкову задачу.

Таким чином, ми звели невідому задачу (all-pairs shortest paths) до вже відомої (single-source shortest paths). Існує хороша властивість: якщо ми за P-час можемо звести невідому задачу \(\pi_?\) до відомої P-задачі \(\pi_0\), невідома задача \(\pi_?\) теж належить до P:

\begin{flalign*}
    \pi_? \xrightarrow{P\:time} \pi_0, \enspace \pi_0 \in P \quad \Rightarrow \quad \pi_? \in P
\end{flalign*}

Оскільки кількість вершин \(V\) --- поліноміальна відносно довжини даних, час виконання алгоритму Дейкстри --- поліноміальний, то задача all-pairs shortest paths --- також має поліноміальну складність і тому входить до P.

«Темною стороною» цього правила є зведення між NP-задачами. Якщо ми хочемо показати, що наша задача --- складна, і навряд чи має поліноміальний розв’язок, ми користуємося протилежним правилом:

\begin{flalign*}
    \pi_0 \xrightarrow{P\:time} \pi_?, \enspace \pi_0 \in NP \quad \Rightarrow \quad \pi_? \in NP
\end{flalign*}

Іншими словами, якщо відома NP-задача \(\pi_0\) зводиться до нашої \(\pi_?\) за P-час, значить наша задача \(\pi_?\) також належить до NP. Дійсно, якби вона належала до P, ми б скористалися попереднім правилом і вирішили б NP-задачу \(\pi_0\) також за час P.



\section{Класи NP-Hard та NP-Complete. Нерозв’язувані задачі}

Повернемося до задачі Knapsack-Optimization. Її можна розглянути як багаторазове застосування задачі Knapsack-Decision, наприклад, «чи можемо ми набрати цінність щонайменше 10? 20? 40? 80? 160?..» і т.д., поки не знайдемо порогове досяжне значення. Воно й буде відповіддю на задачу Knapsack-Optimization. Звідси можна зробити висновок, що задача Knapsack-Optimization не легша, ніж задача Knapsack-Decision.

Бувають також задачі, для яких не просто не існує швидкого алгоритму, а взагалі не існує жодного алгоритму. Класичний приклад такої нерозв’язуваної задачі --- це \textbf{задача зупинки} (Halting Problem): якщо нам заданий код деякої програми та вхідні дані для неї, чи можемо ми визначити, чи ця програма коли-небудь завершиться, чи працюватиме нескінченно?

Задачі, які щонайменше такі ж складні, як і найскладніші задачі в NP, виділяються в окремий клас --- \textbf{NP-Hard}. До цього класу належатиме і задача Knapsack-Optimization, і задача зупинки. Таким чином, зауважимо, що в NP-Hard можуть бути й задачі, які неможливо розв’язати з допомогою комп’ютера (машини Тюрінга).

Всі задачі в NP, які зводяться одна до одної за P-час, формують \textbf{клас задач NP-Complete} (NP-повні задачі). Зведення між деякою відомою NP-повною задачею та невідомою задачею використовується для того, щоб довести, що невідома задача також NP-повна.

Деякі загальновідомі NP-повні задачі:

\begin{enumerate}
    \item Вже відома нам задача Knapsack-Decision.
    \item Hamiltonian Path --- чи існує на графі шлях, що проходить через кожну вершину, і відвідує кожну вершину рівно один раз?
    \item Vertex Cover --- чи існує на графі множина з \(k\) вершин така, що усі ребра мають хоча б один кінець у цій множині?
    \item 3-SAT --- якщо заданий список булевих виразів, в кожен із яких входять деякі 3 змінні (наприклад, |x2 OR x5 OR x7|), чи існує такий спосіб присвоїти кожній змінній значення |true|/|false|, щоб усі вирази одночасно давали результат |true|?
\end{enumerate}

Є набір задач, які мають Decision-версію, що входить в NP-Complete, та Optimization- версію, яка є NP-Hard. Однією з найвідоміших таких задач є \textbf{задача комівояжера} (Traveling Salesman Problem, TSP): задано N міст, між кожною парою міст є пряма дорога довжиною \(w_{i \rightarrow j}\). Потрібно знайти найдешевший спосіб виїхати з деякого початкового міста, відвідати кожне місто рівно один раз і повернутися в початкове місто. Іншими словами, потрібно знайти на зваженому графі гамільтоновий цикл мінімальної ваги (або ваги щонайбільше \(W\) для Decision-версії).

Що робити, якщо ми виявимо, що нам потрібно розв’язати NP-повну задачу?

\begin{itemize}
    \item З’ясувати, чи нам дійсно потрібно вирішувати її в загальному випадку. Можливо, ми маємо справу лише з частковим варіантом. Наприклад, хоч Knapsack-Decision і є NP-повною, проте у випадку цілочисельних ваг ми можемо її розв’язати швидким динамічним алгоритмом.
    \item Можливо, можна вирішити задачу не повним перебором, а швидшим NP-алгоритмом. Наприклад, Optimization-задача комівояжера вирішується повним перебором за час \(O(n!)\), а методом динамічного програмування --- за час \(O(n ^ 2 \cdot 2 ^ n)\) та простір \(O(n \cdot 2 ^ n)\).
    \item Вирішити, чи нам дійсно потрібно завжди розв’язати задачу коректно. Можливо, можна застосувати евристику (наприклад, жадібний чи рандомізований алгоритм), яка виконається швидко і дасть хорошу, проте не найкращу відповідь. Для багатьох бізнес-задач це прийнятний варіант. Наприклад, для задачі комівояжера існує багато евристик, що працюють за P-час і помиляються лише на дуже аномальних даних. Популярною евристикою для TSP є алгоритм 2-OPT, який працює за квадратичний час.
\end{itemize}



\end{document}